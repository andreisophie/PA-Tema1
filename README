# Tema 1 PA

Made by Andrei Mărunțiș

> **Nota**: Acest readme este scris in markdown, deschide-l cu un editor specializat pentru o citire mai usoara.

## Problema 1 - Feribot

Solutia la aceasta problema este inspirata de [aici](https://www.geeksforgeeks.org/allocate-minimum-number-pages/).

Pasii rezolvarii sunt urmatorii:

- Dupa ce am citit datele, consider cazurile in care as avea costul minim, respectiv maxim:
    - costul minim il obtin daca am un numar de feriboturi egal cu numarul de masini, astfel costul va fi greutatea maxima dintre masini
    - costul maxim se obtine daca inghesui toate masinile pe un singur feribot, iar in acest caz costul va fi suma greutatilor tuturor masinilor
- raspunsul cautat (costul minim avand k feriboturi) se afla undeva intre valorile definite mai sus. Pentru a determina eficient costul corect, fac un fel de cautare binara (imi injumatatesc la fiecare pas domeniul de cautare, astfel):
    - Initial `stg=costMinim` si `dr=costMaxim`
    - Calculez mijlocul ca fiind media aritmetica `middle = (stg + dr) / 2`
    - Verific daca este posibil sa transport masinile cu un cost maxim egal cu `middle` (greutatea masinilor de pe fiecare feribot sa fie cel mult egala cu `middle`); fac asta parcurgand liniar vectorul de masini si facand sume partiale
    - Daca gasesc ca este posibil, atunci injumatatesc intervalul de cautare setand `dr = middle - 1` (caut doar solutii cu costul mai mic decat cel pe care l-am gasit deja ca fiind valid)
    - Altfel, injumatatesc intervalul de cautare setand `stg = middle + 1` (caut doar solutii cu costul mai mare decat cel pe care l-am verificat la pasul curent)
    - Continui pasii de mai sus pana cand `stg > dr`
- Ultimul raspuns valid este raspunsul corect al problemei

## Problema 5 - BadGPT

Se observa usor urmatoarea recurenta (absolut identica pentru u si n):

- Fie `u[i]` = numarul de siruri de u/w care se termina in u
- Fie `w[i]` = numarul de siruri de u/w care se termina in w
- Vreau sa calculez `u[i + 1]`, `w[i + 1]`:
    - Pot sa obtin un sir care se termina in u adaugand u la un sir care se termina in u sau w, asadar `u[i + 1] = u[i] + w[i]`
    - Pot sa obtin un sir care se termina in w doar adaugand u la un sir care se termina deja in u si transformand cei doi de u de la final in w, asadar: `w[i + 1] = u[i]`
- Observ astfel ca de fapt nu am nevoie de 2 vectori separati, intrucat `w[i] = u[i - 1]`, oricare ar fi i. Astfel, obtin noua recurenta:
    - `u[i + 1] = u[i] + u[i - 1]`
- Recurenta de mai sus este definitia sirului lui Fibonacci cu primele elemente `u[0] = 0`, `u[1] = 1`. (Sirul lui Fibonacci clasic)
- Numarul total de posibilitati in care un sir de lungime i poate fi intepretat va fi `total[i] = u[i] + w[i] = u[i] + u[i - 1]`.

Astfel, cerinta problemei necesita calculul sirului lui Fibonacci. Trebuie implementata a solutie eficienta atat din punct de vedere spatial, cat si temporal, pentru a respecta restrictia de timp (3s), respectiv limita de memorie a masinii.

Optimizarile pe care le-am facut sunt urmatoarele:

- Calculez elementele sirului lui Fibonacci folosind exponentierea matricilor in timp logaritmic (vezi explicatie la acest [link](https://www.nayuki.io/page/fast-fibonacci-algorithms), sectiunea **Matrix exponentiation**)
- La metoda de mai sus adaug calculul exponentierii in timp logaritmic folosind urmatoarele formule simple:
    - `A^2k = (A^2)^k`
    - `A^(2k + 1) = (A^2)^k * A`
- Sirul lui Fibonacci are proprietatea ca resturile sale modulo orice numar sunt periodice. Lungimile perioadelor modulo 1, 2, 3 etc. formeaza un sir numit sirul lui Pisano. Astfel, folosind codul scris in fisierul `Pisano.java` ([sursa](https://www.geeksforgeeks.org/fibonacci-number-modulo-m-and-pisano-period/)) am determinat (printr-ul calcul separat, "hardcodat") perioada Pisano a sirului lui Fibonacci modulo `10^9+7` si am obtinut perioada `2*10^9+16`. Astfel, a trebuit sa calculez valorile sirului lui Fibonacci pentru al maxim `2*10^9+16`-lea element.
- Am implementat si un mecanism de memoizare in solutia mea; pentru a calcula valorile lui `Fibo[i]` (al i-lea element din sirul lui Fibonacci) prin metoda exponentierei de matrici primesc si valorile `Fibo[i - 1]` si `Fibo[i + 1]` de care e posibil sa am nevoie mai tarziu. Retin aceste valori intr-un HashMap.